<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3552 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC6550 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6550.xml">
<!ENTITY RFC6345 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6345.xml">
<!ENTITY RFC6775 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6775.xml">
<!ENTITY RFC5191 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5191.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="info" docName="draft-jadhav-lwig-nbr-mgmt-policy-00" ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN" 
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
         full title is longer than 39 characters -->

    <title abbrev="Neighbor Management Policy for 6LoWPAN">Neighbor Management Policy for 6LoWPAN</title>
    
    <author fullname="Rahul Arvind Jadhav" initials="R.A." role="editor" surname="Jadhav">
      <organization>Huawei Tech</organization>
      <address>
        <postal>
          <street>Kundalahalli Village, Whitefield,</street>
          <city>Bangalore</city>
          <region>Karnataka</region>
          <code>560037</code>
          <country>India</country>
        </postal>
        <phone>+91-080-49160700</phone>
        <email>rahul.ietf@gmail.com</email>
      </address>
    </author>
    <author fullname="Rabi Narayan Sahoo" initials="R.N." surname="Sahoo">
      <organization>Huawei Tech</organization>
      <address>
        <postal>
          <street>Kundalahalli Village, Whitefield, </street>
          <city>Bangalore</city>
          <region>Karnataka</region>
          <code>560037</code>
          <country>India</country>
        </postal>
        <phone>+91-080-49160700</phone>
        <email>rabinarayan@huawei.com</email>
      </address>
    </author>
    <author initials="S" surname="Duquennoy" fullname="Simon Duquennoy">
      <organization>Inria</organization>
      <address>
        <postal>
          <street>40 Avenue Halley</street>
          <street>Building A</street>
          <city>Villeneuve d'Ascq</city>
          <country>France</country>
        </postal>
        <phone>+33 768227731</phone>
        <email>simon.duquennoy@inria.fr</email>
      </address>
    </author>
    <author fullname="Joakim Eriksson" initials="J.E." surname="Eriksson">
      <organization>SICS</organization>
      <address>
        <postal>
          <street></street>
          <city>TODO</city>
          <region></region>
          <code></code>
          <country>TODO</country>
        </postal>
        <phone></phone>
        <email>joakime@sics.se</email>
      </address>
    </author>

    <date month="December" year="2016" />

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
         in the current day for you. If only the current year is specified, xml2rfc will fill 
	 in the current day and month for you. If the year is not the current one, it is 
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	 specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>General</area>

    <workgroup>LWIG</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>template</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
	  <t>This document describes the problems associated with neighbor
	  management in constrained multihop networks and a sample neighbor
	  management policy to deal with it.</t>
    </abstract>
  </front>

<middle>
	<section title="Introduction">
		<t> In a wireless multihop network, the node densities (maximum number
		devices connected on a single link) may vary significantly depending
		upon deployments/scenarios. While there is some policy control possible
		with regards to the network size in terms of maximum number of devices
		connected, it is especially difficult to set a figure on what will be
		the maximum node density given a deployment.  For e.g. A network can
		put an upper limit on max 1000 devices but it is impossible to state
		what the node density will be in this 1000 node network. </t>

	   <t>Every networked node needs to manage the neighbor entries for
	   resolving MAC addresses. Linux and other operating systems have used
	   neighbor management policies which essentially are first-come,
	   first-serve basis. In case of Linux, the kernel issues a warning when
	   the neighbor table overflows in which case the usual step taken is to
	   tune the negighbor cache size. With constrained nodes, this solution
	   does not help.</t> <!-- SD: Does Linux really has the same problem?
	   Doesn't dynamic memory allocation basically solve everything? -->
   
		<t>A neighbor cache is usually used for populating neighboring one-hop
		connected nodes information such as MAC address, link local IP address
		and other state information. Node density has direct implications on
		the neighbor cache and in constrained network scenario the size of the
		neighbor cache will be limited. Thus there are chances that a node may
		not be able to fit all the neighboring nodes in its table cache in
		which case it has to prioritize entries and thus needs a neighbor
		management policy.</t>

		<t>In this draft, we present problems related to neighbor management
		policies by considering a security-enabled multi-hop 6lo network. We
		specifically consider RPL<xref target="RFC6550"/> as a routing protocol
		and PANA (EAP-PANA)<xref target="RFC5191"/> as a network access
		protocol. For RPL, both the storing and non-storing mode of operations
		are considered. We also provide a sample neighbor management policy
		which can be used in such networks with its limitations and
		assumptions. The aim of such a policy is to retain set of neighbor
		cache entries with high quality links such that routing adjacencies are
		stablized.</t>

		<t>For the rest of this document consider the following topology:
		<figure align="center" anchor="sample_top">
        <!-- <preamble>Preamble text - can be omitted or empty.</preamble> -->

        <artwork align="center"><![CDATA[
                    +--------+
                    | PAA/   |
             +------| Auth   |
             |      | Server |
             |      +--------+
+------------|-------------+ 
|            |             |
|          (BR)            | 
|          / \             |
|         /   \            |
|        /     \           |
|      (N1)   (N2)         |
|      / :     / \         |
|     /   :   /   \        |
|    /     : /     \       |
|  (N8)    (N3)   (N4)     |
|    :     / \     :       |
|     :   /   \   :        |
|      : /     \ :         |
|      (N5)   (New)        |
|      / \                 |
|     /   \                |
|    /     \               |
|  (N6)   (N7)             |
|                          |
|        6Lo Network       |
+--------------------------+ 
            ]]></artwork>
        <postamble>Sample Topology</postamble>
      </figure>
    </t>
        <section title="Requirements Language and Terminology">
			<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
			NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
			in this document are to be interpreted as described in <xref
			target="RFC2119">RFC 2119</xref>.</t>

			<t>PaC: PANA Client. New joining node which is yet to be
			authenticated.</t>
            <t>PRE: PANA Relay Element. <xref target="RFC6345" /> describes a
            mechanism for an already authenticated and network joined node to
            as a relay element for PaCs to complete the authentication
            procedure on multi-hop networks.</t>
			<t>PAA: PANA Auth Agent. Auth server which hosts the credentials
			database. PaC will handshake with PAA to complete authentication
			procedure.</t>
			<t>Routing Child: A downstream node who is part of the routing
			table of the parent. For e.g. in the sample topology above N5 is
			the directly connected routing child for N3.  N6 and N7 are also
			part of N3 routing table, they are routing child nodes but not
			directly connected. For N6 and N7 the document might alternatively
			use a term grand-child.</t> 
			<!-- SD: As the child-parent relation is symmetrical, I suggest to
			either (1) use "direct" for both or (2) not use "direct" at all.  I
			would simply use "Routing Child", and make clear in the text we're
			referring only about direct children, i.e. next hops in the the
			routing table. --> 
			<t>Routing Parent: In the sample topology (<xref
			target="sample_top"/>), N1 and N2 are possible routing parents for
			N3.</t>
			<t>Neighbor Cache Entry (NCE): A neighbor entry managed on behalf
			of directly connected peer.</t>
			<t>This document also uses terminology described in <xref
			target="RFC6550"/> and <xref target="RFC6775"/>.</t>
        </section>
      
    </section>

    <section anchor="nbr_mgmt" title="Neighbor Management">
        <section title="Significance of Neighbor management policy">
			<t>Multihop mesh networks present unique challenges to neighbor
			management especially with resource constrained nodes. In cases
			where the node density is higher that the neighbor cache size, the
			entries have to be prioritized. <xref target="Woo_et_al"/> and
			<xref target="Dawans_et_al"/> talk about prioritization of neighbor
			entries by using link quality estimation techniques. But
			prioritization alone may not necessarily be optimal in all cases.
			The reason or function why neighbor entry was added also needs to
			be taken in consideration. For example, evicting a routing direct
			child might have a ripple effect in turn impacting all the
			sub-childs as well.</t>

			<t>In case of key management protocols deployed above MAC layer in
			multihop network, the neighbor management kicks in early even
			before the routing adjacencies are established. Since a new joining
			node needs to discover/attach to a relay element for completing its
			authentication procedure, the neighbor table entries
<!-- SD: consistency: do we make any difference between "neighbor table" and "neighbor cache"? -->
			have to be appropriately populated both on a PaC and on the PRE. If
			a neighbor entry whose authentication is in progress is evicted, it
			may increase the authentication time drastically.</t>

			<t>Another important consideration is that with increased node
			density, the prioritization based on link estimation parameters
			might not help since there might be more well connected peers. In
			dense deployments the number of directly attached neighbors with
			good quality links might still be higher than the max entries in
			neighbor cache size.</t> 
		</section> 
		<section title="Trivial neighbor management policies"> 
			<t>This section investigates policies which are used by most of the
			current operating systems for constrained nodes. While such
			policies are trivial to implement they may not be able to deal with
			the constrained network scenario. Note that such policies can still
			be utilized or deployed if it is known apriori that the neighbor
			table can hold entries for maximum node density.</t> 
			<t><list style="letters"> 
			<t>First Come First Serve (FCFS) policy</t>
			<t>Least Recently Used (LRU) policy</t> </list> 
			The primary distinction between these policies is how it treats a
			new entry when the neighbor table is full. In case of FCFS policy,
			the new entry is simply rejected while in the case of LRU, the new
			entry replaces the least recently used entry.</t> 
			<t> RPL works by initiating a downstream multicast DIO to establish
			upstream network path. Subsequently DAO messages might be sent by
			the nodes to establish downstream paths to the nodes. Thus the
			network is flooded with multicast DIO messages initially and
			similarly there are chances that the same node is end up been
			selected as a preferred parent by most of the child nodes and thus
			receives a DAO message from all these child nodes. Note that once a
			node establishes a parent entry or a routing entry on behalf of a
			directly connected node then it has to also provision a neighbor
			table entry for it for subsequent unicast traffic.  </t> 
			<t> In case of FCFS policy, a node might end up hosting all the
			neighbor entries based on DIO or DAO messages.  Once the table is
			full and if the node has to switch its parent node, then
			establishing a neighbor entry would mean evicting some existing
			entry.  </t>
			<t> In case of LRU policy, a node might end up churning lot of
			neighbor entries because once the table gets full and there is
			a request for new entry, it would result in evicting the least
			recently used (but active) entry.  If at later point of time,
			there is a traffic for the evicted entry then the old entry has
			to be reinstated using IPv6 NDP procedure. This would mean
			reinstating the entry by evicting another least recently used
			entry. If the node density is very high, then this churn would
			be substantially high to extent that it would disrupt any
			routing adjacencies to be established in the network in a
			stable way.  </t> 
		</section> 
		<section title="Lifecycle of a neighbor entry"> 
			<section title="Insertion"> 
				<t> 
				IPv6 NDP <xref target="RFC6775"/> defines signaling involved in
				resolving the IPv6 addresses to its corresponding MAC addresses
				which in turn gets populated in the neighbor table. In case of
				constrained network, it is desired that such control traffic is
				minimized and thus the neighbor table entries are populated as
				part of existing messaging. One example would be when the node
				receives a DAO message from its immediate child node, it not
				only makes an addition to the routing table but also creates a
				neighbor table entry for the node. Thus it eliminates need for
				additional IPv6 NDP NS/NA messaging involved to resolve MAC
				address. Similar hueristic is made use to add neighbor entries
				in other cases as well. Following are the possible signaling
				scenarios in which case a neighbor entry may get added.
				</t>
				<t>Node Joining procedure: A new joinee node discovers a relay
				element to initiate its authentication procedure. At the end of
				the discovery phase the new joinee node would have known the
                link local IP address of the relay element. The joinee node
                will send an unsecured-NS to the relay element to solicit it's
                NA. The PRE may send a NA with the appropriate status code as
                defined in section 6.5.3 of <xref target="RFC6775" />.
				</t>
				<t>
				The PANA relay element (PRE) on reception of signaling message may
				decide to allow the new joining node to initiate the
				authentication procedure through itself. Relay element does not
				hold any state information on behalf of the new joinee node
				except for its neighbor table entry. Thus in the <xref
				target="sample_top"/> the new joinee node may select node
				N3 as its PRE, in which case N3 has to add a neighbor entry on
				behalf of the new joinee node.
				</t>
				<t>
				Post authentication the node enters into network discovery
				phase. The node selects one or more of its neighboring peer as
				its preferred parent based on the DIO received from these
				peers. Note that the node's selected relay element and its
				preferred parent may not be the same. The preferred parent
				serves as a default router node to which all its upstream
				traffic is directed. Thus a neighbor entry on behalf of
				preferred parent needs to be added. In <xref
				target="sample_top" /> node N5 selects N3 as its preferred
				parent. This case N5 needs to add neighbor entry on behalf of
				N3 which is its directly connected RPL preferred parent.
				</t>
				<t>
				On selection of preferred parent, the node may send a DAO
				message to its preferred parent all the way to the root to
				estalish a downstream path. The preferred parent thus has to
				maintain a neighbor entry on behalf of the directly connected
				child node. For example, in the <xref target="sample_top"/>,
				node N3 needs to maintain a neighbor entry on behalf of N5
				which is its directly connected child node. Nodes N6 and N7 are
				grand-child nodes for node N3 for whom no neighbor entry is
				required.
				</t>
				<t>
				IPv6 NDP procedures might still be used in cases where the
				neighbor entry needs to be refreshed on lifetime expiry.
				</t>

				<t>The sample call flow shows the signaling cases where an NCE
				could be added.
                <figure align="center" anchor="callflow">
                <!-- <preamble>Preamble text - can be omitted or empty.</preamble> -->
                <artwork align="center"><![CDATA[
                                 RPL
       New           PRE         Parent        PAA
        |             |            |            |
        |  PRE Disc   |            |            |
        |<----------->|            |            |
        |             |            |            |
        |   unsec-NS  |            |            |
        |------------>|            |            |
        |             |            |            |
        | unsec-NA(status)         |            |
        |<------------|            |            |
        |             |            |            |
  add_NCE(PRE)        |            |            |
        |             |            |            |
        |    PCI      |            |            |
        |------------>|            |            |
        |             |            |            |
        |        add_NCE(new)      |            |
        |             |            |            |
        |             |  AuthProc  |            |
        |<----------->|<----------------------->|
        |             |            |            |
        |             |  RPL-DIO   |            |
        |<-------------------------|            |
        |             |            |            |
  add_NCE(parent)     |            |            |
        |             |  RPL-DAO   |            |
        |------------------------->|            |
        |             |            |            |
        |             |       add_NCE(new)      |
        |             |            |            |
on NCE lifetime       |            |            |
     expiry           |            |            |
        |            sec-NS        |            |
        |------------------------->|            |
        |             |            |            |
        |             |        upd_NCE(new)     |
        |             |            |            |
        |           sec-NA(Status) |            |
        |<-------------------------|            |
        |             |            |            |
upd_NCE(parent)       |            |            |
        |             |            |            |
        |             |            |            |
                ]]></artwork>
                <postamble>Call Flow</postamble>
                </figure>
                </t>

				<t>
				This document expects the neighbor management policy to
                remember the reason why the neighbor entry is inserted.
                Secondly, the router may remember whether the NS received was
                secured or unsecured and accordingly use it to prioritize
                eviction entries. As described in the later sections, this
                reason will help the policy to prioritize the entries in case
                an eviction is forced.
				</t>
            </section>
            <section title="Deletion">
				<t>It is imperative that an unwanted neighbor entry be removed
				as soon as possible. This section talks about different cases
				in which neighbor entry can be deleted.
				</t>
				<t>
				Route Invalidation: When the child node decides to change its
				preferred parent, the RPL specifications allows the node to
				send a no-path DAO message to invalidate the route along the
				previous path(s). A directly connected parent node can use this
				message to clear the neighbor entry. While the entry can be
				immediately cleared, usually the implementations choose to wait
				a small amount of time before clearing the entry.  This is to
				avoid any impact on the in-transit traffic. Thus this also
				establishes the importance of route invalidation to achieve
				optimized neighbor table utilization.
				</t>
				<t>
				<xref target="RFC6775"/>, ND optimizations for 6LoWPANs,
				section 5.5.3. talks about deleting the entries in case the NUD
				(neighbor unreachability detection) fails either due to no
				response to NS messages or due to failure response. Neighbor
				entries in such cases should be deleted. An example where NUD
				NS would fail because of no response is the case where the
				child node swtiches its parent due to link unavailability. The
				parent in such a case would not receive the no-path DAO message
				or any other traffic from the child node. Thus on entry
				lifetime expiry, the parent node would send NS which would fail
				with no response, thus triggering entry deletion.
				</t>
            </section>
            <section title="Eviction">
				<t>
				The eviction rules have a major impact on the neighbor
				management policy. Eviction rules are used when the policy has
				to forcibly remove an active neighbor entry from the table to
				make space for the new (hopefully higher priority) entry. The
				eviction policy may take into account several considerations
				such as the reason why the entry was made, is the entry in
				active use currently, how good (for e.g., based on link
				estimation) the entry currently is.
				</t>
				<section title="Eviction for directly connected routing entries">
					<t>
					This section talks about implications of an eviction in
					which a parent node decides of evicting a directly
					connected routing child entry. In the sample topology <xref
					target="sample_top"/>, lets assume N3 needs to evict N5
					from its neighbor cache. In case of RPL's storing mode of
					operation, eviction of directly connected routing child
					entry also has impact on all the sub-childs. Thus not only
					will it result in impacting N5 but also nodes N6 and N7. It
					is important to note that such an eviction has less impact
					on RPL's non-storing mode of operation i.e. in case of
					non-storing mode N5 might end up selecting alternate parent
					N8 and does not result in any additional control overhead
					for node N6 and N7.
                    </t>
                    <t>
					Thus RPL's non-storing mode of operation provides
					additional eviction flexibility for a neighbor management
					policy in terms evicting directly connected child entries.
                    </t>
				</section>
			</section>
            <section title="Reinforcement">
                <t>
				It is expected that the latest reachability state and metric
				information be maintained in context to the neighbor entry.
				With wireless networks, the neighbor table entries
				prioritization may change over a period of time especially the
				link quality estimation parameters or the routing metrics.
				Reinforcement refers to updating the parameters in context to
				the neighbor entries which helps in prioritizing the entries
				when it comes to handling eviction. In wireless networks, on
				reception of incoming packet, the receiver node's physical and
				MAC layer may derive certain signal reception parameters (such
				as RSSI, LQI) which can be considered for reinforcement purpose
				if the corresponding transmitter/source entry in neighbor cache
				is found. It should be noted that the signal quality parameters
				may have high variance in 6lo networks and thus statistical
				techniques (such as weighted averaging) are usually employed
				for deciding about a link quality over a period of time.
				Reinforcement can be achieved using one or more of the
				following techniques:
                <list style="hanging"> 
					<t hangText="Passive Monitoring:">Reinforcing the quality
					parameters using packets received from the source. Trickled
					DIO, periodic beacons, application traffic etc can be used
					for such monitoring.</t>
					<t hangText="Active Probing:">A node may select subset of
					entries for active probing wherein it sends a message to
					the neighbor entry's source and can expect a response
					message back. An example of such probing is <xref
					target="CONTIKI"/> where unicast DIS is sent to solicit a
					unicast DIO without impacting the trickle timers. Though it
					adds a control overhead on the link, periodic probing can
					help to ascertain connectivity in the absence of any other
					traffic from the neighboring node.</t>
                </list> 
                </t>
                <!-- SD: To what extent do we want to define probing? Do we only recommend, with one practical example? Or do we want to mandate? -->
            </section>
        </section>
        <section title="Requirements of a good neighbor management policy">
            <t>
            <list style="hanging">
                <t hangText="Route Stability:"></t>
                <t hangText="Control overhead:"></t>
                <t hangText="Easy to implement"></t><!-- SD: I don't think "easy to implement" should be a priority here -->
            </list> blahblah.
            </t>
        </section>
        <section title="Approaches to neighbor management policy">
        <!-- SD: I like the idea to address both proactive and reactive. For proactive, do we plan to advertise the space left in NCE as a DIO metric or similar? -->
            <t>
			Neighbor management policy depends upon the neighbor cache space
			availability and the same can be advertised proactively or can be
			handled reactively.
            </t>
            <section title="Reactive Approach">
                <t>
				In this approach, the nodes select their RPL parent or the
				relay element purely based on link metrics and subsequently
				when they try to allocate their neighbor cache entry in the
				target node, it may fail due to unavailability of the cache
				space. The failure can be communicated in various depending
				upon the signaling involved:
                </t>
                <t> <list style="hanging">
                    <t hangText="NS failure:">
						Section 6.5.3 of <xref target="RFC6775"/> defines a
						procedure for NS failure handling in case the router's
						neighbor cache is full. It results in a unicast NA with
						ARO status field set to two.
                    </t>
                    <t hangText="DAO NACK:">
						Section 6.5.3 of <xref target="RFC6775"/> defines a
						procedure for NS failure handling in case the router's
						neighbor cache is full. It results in a unicast NA with
						ARO status field set to two.
                    </t>
                    <t hangText="PANA Failure:">
                        PaC's Authentication session starts with a PaC
                        discovering a PRE. The discovery procedure is not
                        standardized and can be based upon various factors
                        including signal strength of discovery messages from
                        PRE. Post discovery, the PaC needs to send an unsecured
                        unicast NS message with an ARO containings its
                        link-local IPv6 address. NS helps to determine whether
                        the PRE can allocate an NCE for the PaC. PRE
                        accordingly sends a NA response with appropriate status
                        field.
                    </t>
                </list>
                </t>                
            </section>
            <section title="Proactive Approach">
                <t>
				Neighbor cache availability can be proactively advertised by
				the parent nodes in the DIO messages and in the PRE discovery
				messages. A child RPL node may additionally use this
				information from DIO as part of parent selection process. In
				case on new joinee node, the node may use PRE discovery
				messages with space availability information to select a PRE
				node. Proactive signaling of neighbor cache space availability
				will help the nodes to select the parent node or relay node
				such that the failure signaling due to cache full event can be
				avoided.
                </t>
                <t>
				Currently there is no standard way of signaling such neighbor
				cache space availability information. RPL's DIO messages carry
				metric information and can be augmented with neighbor cache
				space as an additional metric. In case of PRE discovery however
				there is no standard way of defining this information since the
				PRE discovery procedure itself is not standardized. 
                </t>
                <t>
				In a wireless or shared bus network, a multicast DIO metric
				advertisement reaches may reach several child nodes eventually
				everyone responding by selecting the same parent node causing
				neighbor table to be exhausted. Thus the failure handling
				approaches defined in the Reactive Approach section applies
				here as well. But importantly the failure signaling will be
				significantly reduced because of proactive advertisement.
                </t>
            </section>
        </section>
    </section>
    <section title="Reservation based Neighbor Management Policy">
        <!-- SD: we need to define here how we know our children in RPL non-storing.
        If needed, we could enforce a way to use 6lowpan-nd in non-storing context.
        E.g. force NS before switch, so we provision our entry at the future parent before switching.
        Also, with 6lowpan-nd, my understanding is that not only children and parent end up in the table.
        How shall we handle other nodes present in the cache, how to we identify children? -->
		<t>Reservation for direct children and pre-auth entries. Parent nodes
		can still occupy the reserved entries since they could be evicted if
		necessary.
        Describe the actual policy here.</t>
        <t><figure align="center" anchor="reserv_table">
        <!-- <preamble>Preamble text - can be omitted or empty.</preamble> -->

        <artwork align="center"><![CDATA[
<- - - - - - - - - - - Routing Parents - - - - - - - - - - - - ->
+----------------------+----------------------------------------+
|                      |                              |         |
+----------------------+------------------------------+---------+
  Routing Direct-Child                                  Pre-Auth
            ]]></artwork>

        <postamble>Reservation for neighbors based on function</postamble>
        </figure>
        </t>

        <section title="Updates in table structures">
            <t>
            Show various fields of neighbor table, routing table and their relation. Explain newly added fields such as Reason field.
            Storing mode table mapping: 
            Non-storing mode table mapping:
            </t>
        </section>
        <section title="Failure handling">
            <t>How to handle DAO rejection when NBR table is full? </t>
            <t>How to handle PANA rejection when NBR table is full? </t>
            <t>How to handle NS rejection when NBR table is full? What does 6Lowpan-ND say in the context?</t>
        </section>
        <section title="Limitations of such a policy">
            <t>May result in sub-optimal paths.</t>
            <t>Certain scenarios where node density is not high enough, it may result in some nodes getting starved i.e. never able to get any free slot and thus never able to join.</t>
        </section>
        
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>This template was derived from an initial version written by Pekka
      Savola and contributed by him to the xml2rfc project.</t>

      <t>This document is part of a plan to make xml2rfc indispensable <xref
      target="DOMINATION"></xref>.</t>
    </section>

    <!-- Possibly a 'Contributors' section ... -->

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo includes no request to IANA.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
        <t> Add DoS attacks possibily on nbr table </t>
      <t>All drafts are required to have a security considerations section.
      See <xref target="RFC3552">RFC 3552</xref> for a guide.</t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
        &RFC2119;

        <reference anchor="Woo_et_al">
            <!-- the following is the minimum to make xml2rfc happy -->

            <front>
                <title>Taming the Underlying Challenges of Reliable Multihop Routing in Sensor Networks</title>
                <author initials="A" surname="Woo">
                    <organization>University of California</organization>
                </author>
                <author initials="T" surname="Tong">
                    <organization>University of California</organization>
                </author>
                <author initials="D" surname="Culler">
                    <organization>Intel Corp</organization>
                </author>
                <date year="2003" />
            </front>
        </reference>
        
        <reference anchor="Dawans_et_al">
            <front>
                <title>On Link Estimation in Dense RPL Deployments</title>
                <author initials="S" surname="Dawans">
                    <organization>CETIC</organization>
                </author>
                <author initials="S" surname="Duquennoy">
                    <organization>SICS</organization>
                </author>
                <author initials="O" surname="Bonaventure">
                    <organization>Universite Catholique de Louvain</organization>
                </author>
                <date year="2012" />
            </front>
        </reference>
        
        <reference anchor="CONTIKI" target="http://www.contiki-os.org">
            <front>
                <title>Contiki: The Open Source OS for IoT</title>
                <author>
                    <organization>Thingsquare</organization>
                </author>
                <date year="2012"/>
            </front>
        </reference>
    </references>

    <references title="Informative References">
      <!-- Here we use entities that we defined at the beginning. -->

      &RFC3552;

      &RFC6550;
      
      &RFC6775;

      &RFC5191;
      
      &RFC6345;

      <!-- A reference written by by an organization not a person. -->

      <reference anchor="DOMINATION"
                 target="http://www.example.com/dominator.html">
        <front>
          <title>Ultimate Plan for Taking Over the World</title>

          <author>
            <organization>Mad Dominators, Inc.</organization>
          </author>

          <date year="1984" />
        </front>
      </reference>
    </references>

    <section anchor="app-additional" title="Additional Stuff">
      <t>This becomes an Appendix.</t>
    </section>

    <!-- Change Log

v00 2016-11-29  RAJ   Initial version
 -->
  </back>
</rfc>
